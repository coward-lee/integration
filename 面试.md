# JVM

1. 有哪些jvm
    1. Oracle的HotSpot虚拟机； 最常用
    2. BEA System的JRockit虚拟机；也被oracle收购了，主要用于高性能的场景
    3. IBM公司的J9虚拟机； 一站式jvm

2. gc
    1. 有哪些gc收集器
        - Serial （用于回收新生代）（存在stop the world 的情况，因为他在gc的时候是使用单个线程区执行，同时此时只有一个线程在执行回收其他的线程都在等待这个线程gc完成）
        - ParNew （用于回收新生代）（parallel new）并行新生代gc收集器，也就是并行版的serial，serial有的问题他都要
        - Parallel Scavenge （用于回收新生代） 还是会导致stop the world 的情况，但是可以通过参数调整gc的时间和频率
        - G1 （Garbage First1）（不区分？）（全功能收集器 —— Fully-Featured Garbage Collector）      
          这哥们取代了 （Parallel Scavenge + Parallel Old）， 只需要这一个就可以了（Java 7 Update 9 or later）
          G1 算法 将堆内存分为多个块， 然后以块为单位分为（eden，s0，s1，old）；如 1-10 块，有可能分为 （s0:1-2,s1:
          3-4,old5-6,eden7-8,还有两个保留区域）
        - CMS （作用于老年代） 可以并发gc，也就是用户线程执行的时候进行gc，这样可以减少 stop the
          world，但是需要看配置的gc时机（内存使用百分比）需要合适的配置，jdk6以后是92%，    
          但是在jdk9中被 标记为了Deprecate 体检使用G1
        - Serial Old(MSC)（作用于老年代）
        - Parallel Old（作用于老年代）
        - Shenandoah redhat 开发的gc
        - ZGC 对标 Shenandoah
        - PGC （Pauseless GC）
        - C4 （concurrent continuously compacting collector） PGC的演进版
    2. gc 一共有哪几种
        - minor gc （young gc 支队 eden 区域进行gc） (具体方法请看)
        - major GC （Old GC） 只针对 老年代进行GC
        - full gc 这个会对 堆内存和**方法区**都会进行内存回收，会造成stop the world 的问题
    3. GC Root 是什么，有哪些      
       是什么：GC Roots 是一组必须活跃的**引用**。他是一堆**引用**。      
       有哪些：
        - 虚拟机内部的引用，比如类加载器等；
        - native，本地方法栈引用的对象(在本地方法栈)
        - final，常量引用的对象（比如字符串常量池的引用；在方法区）， 这个应该不一定是对的
        - static，静态变量引用的对象（比如Java类的引用类型静态变量；在方法区）
        - synchronzied引用的对象(所有被同步锁持有的对象；在堆里)
        - jvm虚拟机栈引用的对象(比如：各个线程被调用的方法堆栈中用到的参数、局部变量和临时变量；在jvm虚拟机栈中)
        - Thread，活动的线程
        - Class对象，由BootstrapClassLoader加载的对象是不能被回收的
        - 跨代引用的对象也会被GCRoot 引用

    4. gc 算法有哪些
        1. 引用计数法 给每一个对象一个引用计算，为0的就清理，但是无法处理对象间循环引用的情况。
        2. 标记-清除算法
            - 标记 从GC Root 开始 标记对象，如果从GC root 可达的对象就不能被回收，不可达的就可被回收
            - 清除 将可以回收的内存标记为可用状态（回收内存）但是不整理，会产生大量内存碎片

        3. 标记-复制算法
            - 标记 同上
            - 复制 半区复制 将不能被回收的内存，连续的存放到另一半内存中。这样可以保证每次GC完之后都有一个连续内存空间可以使用。
            - G1、CMS、ParNew、Parallel Scavenge 这样的新生代GC算法基本思想都是这个
        4. 标记-整理算法
            - 标记 同上
            - 整理 就是将不连续并且不能被回收的内存整理成为连续的内存
            - 主要用于老年代 也就是 major GC

3. jvm 内存模型    
   ![](./img/jvm_memory.png)
   ![](./img/jvm_memory2.png)

    - 方法区： 线程共享。存储已经被加载的类的信息：常量、静态变量；即时编译器编译后的代码。   
      在jdk1.8（hotspot） 之后 方法区变成了： native memory + meta space
        - native memory： 主要存储 字符串常量池（如我们的String::intern）、静态变量等
        - meta space： 类的一些基本信息
    - 虚拟机栈：线程私有。存储局部变量、**操作数栈**、动态链接、方法出口（return 之后的方法的下一个指令的地址）等信息
        - 操作数栈： 表示 保存计算的中间结果，同时作为计算过程中变量临时的存储空间；
    - 本地方法栈：线程私有。native的方法栈，就是java代码中用native关键休息的栈信息，在 sun hotspot中他们两个被合并了
    - 程序计数器：线程私有。 当前线程下一步执行的位置
    - 堆 ：线程共享。所有的对象实例以及数组都要在堆上分配
    - 代码缓存 jit
      ![](./img/方法区-堆内存.png)
      分代gc收集器才会存在的情况
        - eden 新生代
        - s0 (survivor 0) (from)
        - s1 (survivor 1) (to)
        - 老年代 大对象（通过参数配置）
          gc 流程 （此时是全新的环境，Eden 和 s0 和 s1 都没有任何数据）

        1. 新的对象放入到eden区域，到达gc零界点，进行minor gc
           gc 结果，eden 中存活的对象放入到s0中。 此时 eden为空，s0 存在对象，s1为空
        2. 新的对象放入到eden区域，到达gc零界点，进行minor gc
           gc 结果，eden 和 s0 中存活的对象放入到s1中。此时 eden为空，s0 为空，s1存在对象
        3. 新的对象放入到eden区域，到达gc零界点，进行minor gc
           gc 结果，eden 和 s1 中存活的对象放入到s0中。此时 eden为空，s0 存在对象，s1为空
           ... 以此往复
           这个gc 过程表明s0 和 s1 的作用是一样的
        4. 如果s0/s1 中的对象过次gc后都没有被gc掉，那么就把他放入老年代中。如果老年代，最终也放满了，就会发生 major GC（即
           Full GC）如果老年代，最终也放满了，就会发生 major GC（即 Full GC）；

4. 即时编译 jit

5. Java 为什么能一次编写，处处运行？
   因为java 代码编译后的程序为java字节码文件，这个字节码文件是给jvm虚拟机进行解释执行的，之所以能多次运行都是因为jvm虚拟在多平台实现了

6. JVM 是什么？

7. HotSpot 是什么？
   是jvm虚拟机的一个实现
8. 堆和栈区别是什么？
   堆： 存在实力对象，静态常量（jdk 1.8 之后），数组
   栈： 存放局部变量，返回值地址，操作数栈，动态连接
9. JVM 哪块内存区域不会发生内存溢出？
    1. 堆、栈、元空间、直接内存、**程序计数器**
10. 什么情况下会发生栈内存溢出？

11. 对象都是在堆上分配的吗？
    不一定主要是jvm存在逃逸分析，如果发现对象未能逃逸到当前方法，那么可以直接在栈上进行分配
12. 常用的 JVM 参数有哪些？   
    -Xmx -Xms --add-opens/exports...
13. Java 8 中的内存结构有什么变化？
    方法区 变成了 元空间+常量池(在堆中)
14. Java 8 中的永久代为什么被移除了？
    1、字符串存在永久代中，容易出现性能问题和内存溢出。
    2、类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。
    3、永久代会为GC 带来不必要的复杂度，并且回收效率偏低。
15. JVM 是怎么加载字节码文件的？
    1. 加载
       将java字节码的字节流从外部（文件class文件或者自定义的字节流）加载到方法区（jdk1.8之后改成了元空间）
    2. 验证
       验证字节码是否正确
        - 文件格式验证，是否以coffebaby开始，版本号等
        - 元数据验证： 父类（继承关系验证）、接口/抽象类实现验证、字段等验证
        - 字节码验证 语法和词法验证
        - 符号引用验证： 是否能通过全类名找到引用，访问权限修饰符、
    3. 准备
       初始化静态变量，为其分配初始值（这个初始值不是我们初始值，而是jvm定义的初始值，如int的初始值为0）
    4. 解析
       符号引用的验证，
        - 类和接口
        - 字段
        - 方法
    5. 初始化     
       重要前提这个执行是存在一定顺序性的。。。，这里有一个应用顺序需要注意！！！！！！！
        - 执行java代码中的静态变量赋值语句
        - 执行java代码中的static代码块
    6. 使用
    7. 卸载
16. 什么是类加载器？
    加载class文件到内存中的程序
17. 类加载器（ClassLoader）有哪些方法？
    。。
18. 类加载器的分类及作用？
    启动类加载 c++实现
    扩展类加载 sun.misc.Launcher$ExtClassLoader
    应用程序类加载 sun.misc.Launcher$AppClassLoader
    自定义
19. 编程实现一个自定义的类加载器
    重写的findClass()或loadClass()
20. 什么是双亲委派模型？
    就是加载累的时候，会先给父类进行加载，如果父类没有才会使用自己的类加载
21. 为什么要打破双亲委派模型？
    1. 因为jdk1.2之前那个时候还没有双清委派，
    2. spi 破壞 他直接使用了 应用程序类加载這個去加載
22. Class.forName 和 ClassLoader 的区别？
    1. forName 會去 執行static 代碼，也就是會去多執行一步類加載的**初始化**，但是ClassLoader不會
23. 什么是 JVM 内存模型？
    Java内存模型(Java Memory Model)
    是和多线程相关的一个抽象模型，描述了一组规则或规范，这个规范定义了一个线程对共享变量的写入时对另一个线程是可见的。简而言之，JMM是为了解决多线程环境下可见性问题的一组规范。
24. JAVA 内存模型和 JVM 内存结构的区别？
    1. jvm 內存结构就是，程序运行时的内存布局，也就是我们之前讨论的 堆（常量池）、栈、元空间、代码区、程序计数器

25. 什么是指令重排序？

26. 内存屏障是什么？

27. 什么是 Happens-Before 原则？
- 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；
- 锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作；
- volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；
- 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；
- 线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作；
- 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；
- 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()
  的返回值手段检测到线程已经终止执行；
- 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始。


28. JVM 从 GC 角度看，堆的分区情况？

29. 为什么堆要分新生代和老年代？而不是一个老年代就行？

30. 为什么新生代要分成 Eden 和 Survivor 两个区？

31. 为什么新生代 Survivor 区又分为两个区？一个不行吗？

32. 新生代各分区的默认比例是怎样的？

33. 哪些情况下存活对象会进入老年代？

34. GC 是什么？为什么需要 GC？

35. 什么是 Young GC？

36. 什么是 Minor GC？

37. 什么是 Full GC？

38. 什么时候会触发 Minor GC？

39. 什么时候会触发 Full GC？

40. 一次完整的 GC 流程是怎样的？
    1. 分代原理
        1. 内存先分配在eden区域
        2. 先执行young gc 通过标记复制算法，将eden 和 survivor 复制到另外一个survivor 区域
        3. 在执行major gc 只gc老年带
        4. 在堆全局full gc这个时候常量池也会进行gc

41. 什么是 GC 停顿？为什么要停顿？

42. 如何减少长时间的 GC 停顿？

43. JVM 如何判断一个对象可被回收？

44. 常用的垃圾收集器有哪些？

45. JVM 中的默认垃圾收集器是？

46. 什么是 G1 垃圾收集器？

47. 有了 CMS 收集器，为什么又搞出了 G1？

48. G1 垃圾收集器的适用场景？

49. G1 垃圾收集器有什么优缺点？

50. G1 收集器对于堆是怎么划分的？

51. G1 收集器为什么重新划分了堆？

52. G1 收集器是怎么处理大对象的？

53. G1 收集器为什么新增 Humongous 区域？有什么用？

54. G1 垃圾回收的过程是怎样的？

55. G1 回收停顿了几次，为什么？

56. 怎么启用 G1 收集器？有哪些设置参数？

57. 什么是 CMS 垃圾收集器？

58. CMS 垃圾收集器的适用场景？

59. CMS 垃圾收集器有什么优缺点？

60. CMS 收集器触发 GC 的条件？

61. CMS 垃圾回收的过程是怎样的？

62. CMS 垃圾收集器能处理浮动垃圾吗？为什么？

63. CMS 回收停顿了几次，为什么？

64. CMS 垃圾收集器为什么会被废弃？

65. CMS 垃圾收集器废弃后有什么替代方案？

66. 怎么启用 CMS 收集器？有哪些设置参数？

67. CMS 和 G1 收集器的区别？

68. CMS 和 G1 收集器怎么选？

69. 常用的垃圾回收算法有哪些？

70. 你怎么理解 GC 引用计数算法？

71. 你怎么理解 GC 复制算法？

72. 你怎么理解 GC 标记清除算法？

73. 你怎么理解 GC 标记整理算法？

74. 你怎么理解 GC 分代算法？

75. System.gc() 和 Runtime.gc() 的作用？有什么区别？

76. 什么是三色标记法？

77. 什么是浮动垃圾？

78. 什么是内存泄漏？

79. Java 中会存在内存泄漏吗？

80. 为什么会发生内存泄漏？

81. 如何防止内存泄漏？

82. 一个线程 OOM 后，其他线程还能运行吗？

83. 什么是直接内存？

84. 直接内存有什么用？

85. 怎样访问直接内存？

86. 常用的 JVM 调优命令有哪些？

87. 常用的 JVM 问题定位工具有哪些？

88. 常用的主流 JVM 虚拟机都有哪些？

89. JVM 对频繁调用的方法做了哪些优化？

90. 什么是热点代码？

91. GraalVM 是什么技术？

# JDK

1. 多线程初始化 参数
    - int corePoolSize, 核心线程数量, 这个也可以通过 ThreadPoolExecutor#allowCoreThreadTimeOut(boolean) 来设置与非核心线程同样的效果
    - int maximumPoolSize, 线程池最大线程数量， maximumPoolSize 必须大于等于 corePoolSize， 因为核心线程数 +
      非核心线程数 = 线程池最大线程数量。
    - long keepAliveTime, 空闲线程的存活时间， 这个存活时间是指当非核心线程处于空闲状态后还可以存活多久
    - TimeUnit unit, 存储时间的时间单位
    - BlockingQueue<Runnable> workQueue, 提交任务的任务队列，用于存放我们使用的 submit 或者execute 方法提交的runnable实例对象
    - ThreadFactory threadFactory, 线程工厂
    - RejectedExecutionHandler handler 拒绝策略
2. 序列化和反序列化

3. guava Cache
   LocalCache 数据结构
   ![](./img/guava_cache.png)
   重要的成员变量

```java
class LocalCache {
    // 这个就是一个缓存的分区，不同的key可能存在于不同的分区
    final Segment<K, V>[] segments;
    /**
     * The recency queue is used to record which entries were accessed for updating the access list's ordering. It is drained as a batch operation when either the DRAIN_THRESHOLD is crossed or a write occurs on the segment.
     * 批量加入到
     */
    final Queue<ReferenceEntry<K, V>> recencyQueue;
    final Queue<ReferenceEntry<K, V>> writeQueue;
    final Queue<ReferenceEntry<K, V>> accessQueue;

    static class Segment<K, V> extends ReentrantLock {

    }

}
```

# Redis

0. 底层数据类型
    - intset 一个数字的有序集合
    - SDS简单字符串 封装加功能
    - ziplist 压缩列表
    - linked list 链表
    - quick list 快表 ziplist linkedlist
    - dict 散列表
    - skip list 跳表
    -
1. 基本数据类型
    - 字符串对象
      SDS
    - 列表对象
      quick list （块内用zip list， 快外用linked list）(zip list 存储连锁更新的问题)
    - 集合对象   
      分别用dict和intset存储
        - 有序集合对象  
          ziplist     
          dict     
          skiplist
    - 散列表对象（hash）     
      ziplist 到达一定的临界值转成 散列表，这个可以用过配置配置
      散列表（hashtable）
    - 模块对象和流对象
      list pack

# MySQL

# netty
