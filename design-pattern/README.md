# 设计模式的七大原则
## 1. 单一职责
## 2. 接口隔离     
客户端不应该依赖不需要额接口，即一个类对另一个类的依赖应该建立在最小的接口上，就是可以适当的接口的粒度划分的跟详细一点
## 3. 依赖倒转     
  3.1 高层模块不应该依赖底层模块，二者都应该依赖其抽象，     
  3.2 抽象不应该依赖细节，细节应该抽象      
  3.3 依赖倒置的中心思想是面向接口编程      
  3.4 以抽象为继承进行设计，       
  3.5 接口指定规范，细节有实现类进行操作         
* 注意事项和细节
   1. 底层模块尽量都要有抽象类或者接口，这样程序的稳定性更好
   2. 变量声明类尽量是抽象类或接口，这样我们的变量引用和实际对象间，就存在一个缓冲层，利于程序拓展和优化
   3. 继承的时候需要遵守里氏替换原则     
## 4. 里氏替换
   基本介绍     
    4.1 里氏替换原则(Liskov Substitution Principle)在1988年，由麻省理工学院的以为姓里的女士提出的。        
    4.2 如果对每个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都代换成o2时，
    程序P的行为没有发生变化，那么类型T2是类型T1的子类型。换句话说，所有引用基类的地方必须能透明地使用其子类的对象。
    就是使用父类，同时可以随意替换实现的子类        
    4.3 在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法        
    4.4 里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过聚合, 组合, 依赖来解决问题。
## 5. 开闭原则
5.1. 一个软件的类体类，模块和函数对拓展开放，对修改进行关闭，(对于使用者来说)。用抽象构架框架，用实现拓展细节。
5.2. 当软件需要变化是，尽量通过拓展软件实体的雷伟来实现变化，为不是通过修改已经有的代码来实现变化。
## 6. 迪米特法则        
  基本介绍      
  6.1 一个对象应该对其他对象保持最少的了解        
  6.2 类与类关系越密切,耦合度越大        
  6.3 迪米特法则(Demeter Principle)又叫最少知道原则，即一个类对自己依赖的类知道的
       越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的public方法，不对外泄露任何信息      
  6.4 迪米特法则还有个更简单的定义:只与直接的朋友通信              
  6.5 直接的朋友:每个对象都会与其他对象有耦合关系,只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。       
  其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。      
  也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。     
  迪米特是为了降低耦合不是完全没有依赖
## 7. 合成复用原则
能用聚合和合成的原则，就不要使用继承      
就是将类之间的关系将继承换位依赖       


# UML 
note :对uml的注释


# 设计模式
1. 工厂模式     
2. 原型模式         
    包：design.pattern.factory
3. 构造器模式        
    包：design.pattern.build
4. 适配器模式        
    包：design.pattern.build      
    1. 类的适配器    VoltageAdapter      
    2. 对象适配器    VoltageAdapter2     
    3. 接口适配器    DefaultAdapterPattern       
    4. 源码分析： spring-mvc中adapter个controller的映射关系的适配，在DispatcherServlet#doDispatch 方法 
5. 桥接器模式        
    包：design.pattern.bridge     
6. 装饰着模式        
    包：design.pattern.decorator      
    和桥接有相似之处，都是为了增强拓展性，被装饰者可以被装饰器不断的进行装饰叠加。     
7. 组合模式             
    包：design.pattern.composite      
    Map 组合的父级节点（这里他是接口）,AbstractMap（这里是抽象类）     
    HashMap  这个是中间的节点，实现了接口，继承了抽象类      
    Node为叶子节点       
    Map下面的体系使用的就是组合模式       
8. 外观模式             
    包：design.pattern.facade     
    外观类：去整合所有需要调用的子系统/模块，并为之提供调用端统一地调用接口        
    调用者：外观调用者       
    子系统结合： 之模块或者子系统，处理Facade对象指派的任务，他是实际功能的提供者          
 9. 享元模式（flyweight Pattern, 也称之为蝇量模式）       
    包：design.pattern.       
    当需求相似度很高的时候可以使用这个模式     
    享元模式使用的时候需要分析出来内部状态（相对稳定）和外部状态（变化相对较多）。     
    就是将共用的内容缓存起来，供大家一起使用，使用的时候不用再去创建了       
    如：Integer类的-127 —— 128之间的数就使用了缓存存起来，使用的时候就如果在范围类就直接取出来缓存。
10. 模板模式        
    包：design.pattern.template           
    就是将基本流程写出来，然后将需要定制化的抽象出来就行了。        
11. 命令模式                
    包：design.pattern.template           
    将发起请求的对象与执行请求的对象解耦      
12. 访问者模式       
    应用场景需要对一个对象结构中的对象进行很多不同操作（这些操作彼此没有关联），同时需要避免这些操作”污染“这些对象的类.     
    增强拓展性       
    这个有一个双分派的问题     
    这里使用了一个双分派，首先在客户端中吗，将具体状态作为参数传递Woman中（第一次分派）                
    然后将woman 类作为参数的具体方法中方法getWomanResult,同时将自己（this）作为参数传入，完成第二次分派
13. 观察者模式

14. 中介模式
    就是再调用的是时候交给一个中介来发送消息（或者执行调用）。
    使用中介着模式只需要调用对应的中介，就行了
    
