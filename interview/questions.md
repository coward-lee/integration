# 数据库缓存最终一致性的四种方案
  url : https://segmentfault.com/a/1190000040130840
1. 方案一      
  通过 key 的过期时间，mysql 更新时，redis 不更新。 这种方式实现简单，但不一致的时间会很长。如果读请求非常频繁，且过期时间比较长，则会产生很多长期的脏数据。        
2. 方案二      
  在方案一的基础上扩展，通过 key 的过期时间兜底，并且，在更新 mysql 时，同时更新 redis。      
3. 方案三      
    针对方案二的同步写 redis 进行优化，增加消息队列，将 redis 更新操作交给 kafka，由消息队列保证可靠性，再搭建一个消费服务，来异步更新 redis。
4. 方案四      
  通过订阅 binlog 来更新 redis，把我们搭建的消费服务，作为 mysql 的一个 slave，订阅 binlog，解析出更新内容，再更新到 redis。
  
  